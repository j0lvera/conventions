# Go API Service Conventions

Conventions specific to building HTTP API services with Go, Echo, and FX.

## Quick Start

### Scaffold the Project

```bash
mkdir go-project
cd go-project
go mod init github.com/j0lvera/go-project
touch main.go
```

### Hello World

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world")
}
```

### Add FX

```bash
go get go.uber.org/fx
```

```go
package main

import (
    "fmt"
    "go.uber.org/fx"
)

func main() {
    fmt.Println("Hello, World!")
    fx.New().Run()
}
```

### Add Echo

```bash
go get github.com/labstack/echo/v4
```

Restructure for standard directory layout:

```bash
mkdir cmd/main
mv main.go cmd/main/main.go
mkdir -p internal/api 
touch internal/api/api.go
```

## Service Architecture

Our API services follow a clean, layered architecture pattern with clear separation of concerns:

1. **Handler Layer** (`handler.go`) - HTTP request/response handling
2. **Service Layer** (`service.go`) - Business logic implementation
3. **Store Layer** (`store.go`) - Data access and persistence
4. **Types** (`types.go`) - Interfaces, parameter objects, result objects

### File and Component Naming Conventions

#### Files
- `handler.go` - Contains HTTP handlers and routing logic
- `service.go` - Contains business logic implementation
- `store.go` - Contains data access logic
- `types.go` - Contains interfaces, parameter objects, and result objects
- `module.go` - FX module wiring

#### Components
- `Handler` - HTTP request handler struct
- `Service` - Business logic interface and implementation
- `Store` - Data access interface and implementation

We use these concise names because they're clear in context:

```go
// Example usage
store := NewStore(dbClient)
service := NewService(store, logger)
handler := NewHandler(service, logger)
```

### Additional Structure Rules
- Don't use `models.go` because `sqlc` takes care of this
- Always AVOID circular dependencies. Implement code that prevent import cycles
- DON'T update code generated by `sqlc`

## FX Module Pattern

Create the API module following FX idioms:

```go
// internal/api/api.go
package api

import (
    "context"
    "errors"
    "fmt"
    "net/http"

    "github.com/labstack/echo/v4"
    "go.uber.org/fx"
)

type Result struct {
    fx.Out
    Echo *echo.Echo
}

func New(lc fx.Lifecycle) (Result, error) {
    e := echo.New()

    lc.Append(
        fx.Hook{
            OnStart: func(ctx context.Context) error {
                go func() {
                    if err := e.Start(":8080"); err != nil && !errors.Is(
                        http.ErrServerClosed, err,
                    ) {
                        fmt.Printf("Error starting server: %v\n", err)
                    }
                }()
                return nil
            },
            OnStop: func(ctx context.Context) error {
                fmt.Println("Stopping server...")
                return e.Shutdown(ctx)
            },
        },
    )

    return Result{
        Echo: e,
    }, nil
}

func Module() fx.Option {
    return fx.Module(
        "api",
        fx.Provide(New),
        fx.Invoke(
            func(e *echo.Echo) {
                fmt.Println("API Module initialized")
            },
        ),
    )
}
```

### Config Integration

```go
// config/config.go
package config

import (
    "github.com/kelseyhightower/envconfig"
    "go.uber.org/fx"
)

type Config struct {
    Env  string `envconfig:"ENV" default:"dev"`
    Port string `envconfig:"PORT" default:"8080"`
}

func (c Config) LoadEnv() (Config, error) {
    cfg := c
    if err := envconfig.Process("", &cfg); err != nil {
        return c, err
    }
    return cfg, nil
}

func New() (*Config, error) {
    var cfg Config
    loadedCfg, err := cfg.LoadEnv()
    if err != nil {
        return nil, err
    }
    return &loadedCfg, nil
}

func Module() fx.Option {
    return fx.Module(
        "config",
        fx.Provide(New),
    )
}
```

Use config in API module:

```go
type Params struct {
    fx.In
    Config *config.Config 
}

func New(lc fx.Lifecycle, p Params) (Result, error) { 
    e := echo.New()

    lc.Append(
        fx.Hook{
            OnStart: func(ctx context.Context) error {
                go func() {
                    fmt.Println("Starting server on " + p.Config.Port)
                    if err := e.Start(":" + p.Config.Port); err != nil && !errors.Is(
                        http.ErrServerClosed, err,
                    ) {
                        fmt.Printf("Error starting server: %v\n", err)
                    }
                }()
                return nil
            },
            OnStop: func(ctx context.Context) error {
                fmt.Println("Stopping server...")
                return e.Shutdown(ctx)
            },
        },
    )

    return Result{Echo: e}, nil
}
```

## Domain Module Pattern

Each business domain follows this exact pattern:

```go
// internal/{domain}/module.go
type Params struct {
    fx.In
    Logger zerolog.Logger
    Echo   *echo.Echo
    DB     *db.Client
    Config *config.Config
}

type Result struct {
    fx.Out
    Handler *Handler
    Service Service
}

func New(p Params) (Result, error) {
    store := NewStore(p.DB, &p.Logger)
    svc := NewService(store, &p.Logger)
    handler, err := NewHandler(svc, &p.Logger, p.Config)
    if err != nil {
        return Result{}, fmt.Errorf("unable to create handler: %w", err)
    }
    return Result{Handler: handler, Service: svc}, nil
}

func Module() fx.Option {
    return fx.Module(
        "domain",
        fx.Provide(New),
        fx.Invoke(func(logger zerolog.Logger, echo *echo.Echo, handler *Handler) {
            handler.Routes(echo)
            logger.Info().Msg("Domain module initialized")
        }),
    )
}
```

## Type Definitions

### Parameter Objects
Define purpose-specific input structs for each operation:

```go
type (
  // DetailInput for retrieving a single resource
  DetailInput struct {
    UUID string `param:"uuid" validate:"required"`
  }

  // CreateInput for creating a new resource
  CreateInput struct {
    Name        string `json:"name" validate:"required,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // UpdateInput for updating an existing resource
  UpdateInput struct {
    UUID        string  `param:"uuid" validate:"required"`
    Name        *string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
    Description *string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // ListInput for listing resources with pagination
  ListInput struct {
    pagination.Input
    Filter string `query:"filter,omitempty"`
  }

  // DeleteInput for deleting a resource
  DeleteInput struct {
    UUID string `param:"uuid" validate:"required"`
  }
)
```

### Result Objects
Define purpose-specific output structs for each operation:

```go
type (
  // DetailOutput represents the response for a single resource
  DetailOutput struct {
    UUID        string `json:"uuid"`
    Name        string `json:"name"`
    Description string `json:"description"`
  }

  // CreateOutput is often an alias for DetailOutput
  CreateOutput = DetailOutput

  // ListOutput represents a paginated list of items
  ListOutput struct {
    Items      []DetailOutput    `json:"items"`
    Pagination pagination.Output `json:"pagination"`
  }
)
```

### Interfaces
```go
type (
    Store interface {
        Detail(ctx context.Context, input DetailInput, uid string) (*DetailOutput, error)
        Create(ctx context.Context, input CreateInput, uid string) (*CreateOutput, error)
        Update(ctx context.Context, input UpdateInput, uid string) (*UpdateOutput, error)
        Delete(ctx context.Context, input DeleteInput, uid string) error
        List(ctx context.Context, input ListInput, uid string) (*ListOutput, error)
    }
    
    Service interface {
        Detail(ctx context.Context, input DetailInput, uid string) (*DetailOutput, error)
        Create(ctx context.Context, input CreateInput, uid string) (*CreateOutput, error)
        Update(ctx context.Context, input UpdateInput, uid string) (*UpdateOutput, error)
        Delete(ctx context.Context, input DeleteInput, uid string) error
        List(ctx context.Context, input ListInput, uid string) (*ListOutput, error)
    }
)
```

## Handler Patterns

### Standard CRUD Handler Structure

```go
type Handler struct {
    svc    Service
    logger *zerolog.Logger
    cfg    *config.Config
}

func NewHandler(svc Service, logger *zerolog.Logger, cfg *config.Config) (*Handler, error) {
    return &Handler{svc: svc, logger: logger, cfg: cfg}, nil
}

func (h *Handler) Routes(e *echo.Echo) {
    g := e.Group(h.Pattern())
    g.GET("/:uuid", h.Detail(), middleware.Process[DetailInput]())
    g.GET("", h.List(), middleware.Process[ListInput]())
    g.POST("", h.Create(), middleware.Process[CreateInput]())
    g.PUT("/:uuid", h.Update(), middleware.Process[UpdateInput]())
    g.DELETE("/:uuid", h.Delete(), middleware.Process[DeleteInput]())
}
```

### Handler Implementation Pattern

```go
func (h *Handler) Create() echo.HandlerFunc {
    return func(c echo.Context) error {
        ctx := c.Request().Context()
        requestID := utils.GetRequestID(c)
        input := c.Get("input").(CreateInput)
        uid := c.Request().Header.Get("X-User-ID")
        
        if uid == "" {
            h.logger.Warn().Str("request_id", requestID).Msg("missing X-User-ID header")
            return response.Forbidden(c, "User identifier is missing")
        }

        h.logger.Debug().
            Str("request_id", requestID).
            Interface("params", input).
            Msg("resource creation")

        resource, err := h.svc.Create(ctx, input, uid)
        if err != nil {
            h.logger.Error().
                Err(err).
                Str("request_id", requestID).
                Interface("params", input).
                Msg("failed to create resource")
            return errors.HandleError(c, err, "resource")
        }

        h.logger.Info().
            Str("request_id", requestID).
            Str("resource_uuid", resource.UUID).
            Msg("resource created successfully")

        return c.JSON(http.StatusCreated, response.Response{
            Data: resource,
            Meta: &response.Meta{
                RequestID: requestID,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
            },
        })
    }
}
```

## Service Layer Pattern

```go
type Config struct {
    store  Store
    logger *zerolog.Logger
}

// Implementation is lowercase (unexported)
type service struct {
    cfg Config
}

func NewService(store Store, logger *zerolog.Logger) Service {
    return &service{
        cfg: Config{
            store:  store,
            logger: logger,
        },
    }
}

func (s *service) Create(ctx context.Context, input CreateInput, uid string) (*CreateOutput, error) {
    s.cfg.logger.Debug().
        Str("operation", "service_create").
        Interface("input", input).
        Msg("creating resource")
        
    return s.cfg.store.Create(ctx, input, uid)
}
```

## Store Layer with Row-Level Security

```go
type Config struct {
    client *db.Client
    logger *zerolog.Logger
}

// Implementation is lowercase (unexported)
type store struct {
    cfg Config
}

func NewStore(client *db.Client, logger *zerolog.Logger) Store {
    return &store{
        cfg: Config{
            client: client,
            logger: logger,
        },
    }
}

func (s *store) Create(ctx context.Context, input CreateInput, uid string) (*CreateOutput, error) {
    s.cfg.logger.Debug().
        Str("operation", "store_create").
        Str("user_id", uid).
        Msg("creating resource in database")
        
    tx, err := s.cfg.client.Pool.Begin(ctx)
    if err != nil {
        return nil, fmt.Errorf("store: failed to begin transaction: %w", err)
    }
    defer tx.Rollback(ctx)

    // Set user context for RLS
    _, err = tx.Exec(ctx, "select set_config('app.user_id', $1, true)", uid)
    if err != nil {
        return nil, fmt.Errorf("store: failed to set user_id for rls: %w", err)
    }

    qtx := s.cfg.client.Queries.WithTx(tx)
    
    params := dbgen.CreateResourceParams{
        Name:        input.Name,
        Description: pgtype.Text{String: input.Description, Valid: input.Description != ""},
    }

    resource, err := qtx.CreateResource(ctx, params)
    if err != nil {
        var pgErr *pgconn.PgError
        if errors.As(err, &pgErr) && pgErr.Code == "23505" {
            return nil, customErrors.ErrConflict
        }
        return nil, fmt.Errorf("store: failed to create resource: %w", err)
    }

    if err := tx.Commit(ctx); err != nil {
        return nil, fmt.Errorf("store: failed to commit transaction: %w", err)
    }

    return &CreateOutput{
        UUID: resource.Uuid,
        Name: resource.Name,
        Description: resource.Description.String,
    }, nil
}
```

## Middleware Patterns

### Generic Request Processing

```go
func Process[I any]() echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            var input I
            if err := c.Bind(&input); err != nil {
                return response.BadRequest(c, "Invalid request format", nil)
            }
            if err := c.Validate(input); err != nil {
                validationDetails := errPkg.ValidationError(err)
                return response.BadRequest(c, "Validation failed", validationDetails)
            }
            c.Set("input", input)
            return next(c)
        }
    }
}
```

### Request Logging Middleware

```go
func LogRequest(logger *zerolog.Logger) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            start := time.Now()
            
            logEvent := logger.Debug().
                Str("method", c.Request().Method).
                Str("path", c.Request().URL.Path).
                Str("remote_ip", c.RealIP()).
                Str("request_id", c.Response().Header().Get(echo.HeaderXRequestID))
            
            if input := c.Get("input"); input != nil {
                logEvent = logEvent.Interface("params", input)
            }
            
            logEvent.Msg("request started")
            err := next(c)
            duration := time.Since(start)
            
            var event *zerolog.Event
            status := c.Response().Status
            
            switch {
            case duration > 1*time.Second:
                event = logger.Warn().Str("warning", "slow_request")
            case status >= 500:
                event = logger.Error()
            case status >= 400:
                event = logger.Warn()
            default:
                event = logger.Info()
            }
            
            event.Str("method", c.Request().Method).
                Str("path", c.Request().URL.Path).
                Int("status", status).
                Dur("duration", duration).
                Str("request_id", c.Response().Header().Get(echo.HeaderXRequestID)).
                Msg("request completed")
            
            return err
        }
    }
}
```

## Database Integration

### Database Client Pattern

```go
type Client struct {
    Queries *dbgen.Queries
    Pool    *pgxpool.Pool
}

func NewClient(pool *pgxpool.Pool) *Client {
    return &Client{
        Queries: dbgen.New(pool),
        Pool:    pool,
    }
}

func New(lc fx.Lifecycle, p Params) (Result, error) {
    pool, err := pgxpool.New(context.Background(), p.Config.DatabaseURL)
    if err != nil {
        return Result{}, fmt.Errorf("unable to create connection pool: %w", err)
    }

    client := NewClient(pool)

    lc.Append(fx.Hook{
        OnStart: func(ctx context.Context) error {
            p.Logger.Info().Msg("Database connection established")
            return pool.Ping(ctx)
        },
        OnStop: func(ctx context.Context) error {
            p.Logger.Info().Msg("Closing database connection")
            pool.Close()
            return nil
        },
    })

    return Result{Client: client}, nil
}
```

## Error Handling

### Domain Errors

```go
var (
    ErrNotFound     = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized access")
    ErrConflict     = errors.New("resource conflict")
)

func HandleError(c echo.Context, err error, resource string) error {
    switch {
    case errors.Is(err, ErrNotFound):
        return response.NotFound(c, resource)
    case errors.Is(err, ErrUnauthorized):
        return response.Forbidden(c, "Access denied")
    case errors.Is(err, ErrConflict):
        return response.Conflict(c, resource+" already exists")
    default:
        return response.InternalError(c)
    }
}
```

## Response Patterns

### Consistent API Responses

```go
type Response struct {
    Data       interface{} `json:"data,omitempty"`
    Pagination interface{} `json:"pagination,omitempty"`
    Error      *Error      `json:"error,omitempty"`
    Meta       *Meta       `json:"meta,omitempty"`
}

type Meta struct {
    RequestID string `json:"request_id"`
    Timestamp string `json:"timestamp"`
}

func Success(c echo.Context, data interface{}) error {
    return c.JSON(200, Response{
        Data: data,
        Meta: &Meta{
            RequestID: c.Response().Header().Get(echo.HeaderXRequestID),
            Timestamp: time.Now().UTC().Format(time.RFC3339),
        },
    })
}
```

## Logging Conventions

### Structured Logging with Request Correlation

```go
// Debug: Operation start with parameters
h.logger.Debug().
    Str("request_id", requestID).
    Interface("params", input).
    Msg("resource creation")

// Info: Successful operations with identifiers
h.logger.Info().
    Str("request_id", requestID).
    Str("resource_uuid", resource.UUID).
    Msg("resource created successfully")

// Error: Failures with context
h.logger.Error().
    Err(err).
    Str("request_id", requestID).
    Interface("params", input).
    Msg("failed to create resource")
```

## Security Patterns

### Row-Level Security Implementation

```go
// Always set user context for RLS
_, err = tx.Exec(ctx, "select set_config('app.user_id', $1, true)", uid)
if err != nil {
    return nil, fmt.Errorf("store: failed to set user_id for rls: %w", err)
}

// User ID validation in handlers
uid := c.Request().Header.Get("X-User-ID")
if uid == "" {
    h.logger.Warn().Str("request_id", requestID).Msg("missing X-User-ID header")
    return response.Forbidden(c, "User identifier is missing")
}
```

## Testing Patterns

### Integration Test Structure

```go
func TestMain(m *testing.M) {
    _, cleanup := testutil.SetupTestSuite()
    exitCode := m.Run()
    cleanup()
    os.Exit(exitCode)
}

func TestCreateResource(t *testing.T) {
    is := is.New(t)
    
    resourceData := map[string]interface{}{
        "name":        "Test Resource",
        "description": "A resource for testing.",
    }

    body, err := json.Marshal(resourceData)
    is.NoErr(err)

    req, err := http.NewRequest("POST", testutil.TestBaseURL+"/resources", bytes.NewReader(body))
    is.NoErr(err)
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("X-User-ID", "test-user-123")

    client := &http.Client{}
    resp, err := client.Do(req)
    is.NoErr(err)
    defer resp.Body.Close()

    is.Equal(resp.StatusCode, http.StatusCreated)
}
```

## Key Architectural Principles

1. **FX Dependency Injection**: All components are wired through FX modules
2. **Three-Layer Architecture**: Clear separation between HTTP, business logic, and data access
3. **Row-Level Security**: Database-level security using PostgreSQL RLS
4. **Request Correlation**: Every request has a unique ID for tracing
5. **Structured Logging**: Consistent logging with context throughout the request lifecycle
6. **Type Safety**: Strong typing with validation at the HTTP boundary
7. **Error Handling**: Domain errors mapped to appropriate HTTP responses
8. **Transaction Management**: Proper database transaction handling with rollback
9. **Generic Middleware**: Reusable request processing with type safety
10. **Consistent Patterns**: Same structure across all business domains