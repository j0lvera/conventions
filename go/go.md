# Go Conventions

When writing Go code, you MUST follow these conventions.

## General Code Quality

- Code should be easy to read and understand.
- Keep the code as simple as possible. Avoid unnecessary complexity.
- Use meaningful names for variables, functions, etc. Names should reveal intent. But at the same time, they should follow Go conventions.
- Functions should be small and do one thing well.
- Prefer fewer arguments in functions. Ideally, aim for no more than two or three arguments.
  - If the function needs more than three arguments, consider using functional-options. You can read more about this in the example below.
- Only use comments when necessary, as they can become outdated. Instead, strive to make the code self-explanatory.
- When comments are used, they should add useful information that is not readily apparent from the code itself.
- Consider security implications of the code. Implement security best practices to protect against vulnerabilities and attacks.
- Follow the Go style guide.

## Service Architecture

Our services follow a clean, layered architecture pattern with clear separation of concerns:

1. **Handler Layer** (`handler.go`) - HTTP request/response handling
2. **Service Layer** (`service.go`) - Business logic implementation
3. **Store Layer** (`store.go`) - Data access and persistence
4. **Types** (`types.go`) - Interfaces, parameter objects, result objects

### File and Component Naming Conventions

#### Files
- `handler.go` - Contains HTTP handlers and routing logic
- `service.go` - Contains business logic implementation
- `store.go` - Contains data access logic
- `types.go` - Contains interfaces, parameter objects, and result objects

#### Components
- `Handler` - HTTP request handler struct
- `Service` - Business logic interface and implementation
- `Store` - Data access interface and implementation

We use these concise names because they're clear in context:

```go
// Example usage
svcStore := ledger.NewStore(dbClient)
svcService := ledger.NewService(svcStore, logger)
svcHandler := ledger.NewHandler(svcService, logger)
```

### Additional Structure Rules
- Don't use `models.go` because `sqlc` takes care of this.
- Always AVOID circular dependencies. Implement code that prevent import cycles.
- DON'T update code generated by `sqlc`.

## Functional Options Pattern

```go
// Functional option example
package main

type Server struct {
	config Config
}

func NewServer(config Config) (*Server, error) {
	return &Server{
		config: config,
	}, nil
}

type Config struct {
	listenAddr string
	id         string
	name       string
}

func (c Config) WithName(name string) Config {
	c.name = name
	return c
}

func (c Config) WithID(id string) Config {
	c.id = id
	return c
}

func (c Config) WithListenAddr(addr string) Config {
	c.listenAddr = addr
	return c
}

func NewConfig() Config {
	return Config{
		id:         "randomuuid",
		name:       "defaultName",
		listenAddr: ":3000",
	}
}

// Usage
func main() {
	config := NewConfig().
		WithID("longuuid").
		WithName("my server").
		WithListenAddr(":8000")
	server, _ := NewServer(config)
	fmt.Println(server)
}
```

## Builder Pattern

Use this pattern for creating service components:

```go
package pkgname

type Config struct {
  store Store
  logger *zerolog.Logger // Always include logger in all layers
}

// Implementation is lowercase (unexported)
type service struct {
  cfg Config
}

// Constructor returns the interface type
func NewService(store Store, logger *zerolog.Logger) Service {
  return &service{
    cfg: Config{
      store: store,
      logger: logger,
    }
  }
}
```

## Type Definitions

### Parameter Objects
Define purpose-specific input structs for each operation:

```go
type (
  // GetInput for retrieving a single resource
  GetInput struct {
    UUID string `param:"uuid" validate:"required"`
  }

  // CreateInput for creating a new resource
  CreateInput struct {
    Name        string `json:"name" validate:"required,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // UpdateInput for updating an existing resource
  UpdateInput struct {
    UUID        string `param:"uuid" validate:"required"`
    Name        string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // ListInput for listing resources with pagination
  ListInput[P any] struct {
    Pagination P
  }

  // DeleteInput for deleting a resource
  DeleteInput struct {
    GetInput
  }
)
```

### Result Objects
Define purpose-specific output structs for each operation:

```go
type (
  // GetOutput represents the response for a single resource
  GetOutput struct {
    UUID        string `json:"uuid"`
    Name        string `json:"name"`
    Description string `json:"description"`
  }

  // CreateOutput is often an alias for GetOutput
  CreateOutput = GetOutput

  // ListOutput represents a paginated list of items
  ListOutput[T any, P any] struct {
    Items      []T `json:"items"`
    Pagination P   `json:"pagination"`
  }
)
```

## Return Types

### Single Objects
Return pointers (`*Type`) when:
- The object might not exist (nil can represent "not found")
- The object is large or contains reference types
- The object might be modified by the caller

```go
// Example: Single object returns use pointers
func GetResource(id string) (*Resource, error) {
  if notFound {
    return nil, errors.New("not found")
  }
  return &Resource{...}, nil
}
```

### Collections
Return slices of values (`[]Type`) when:
- Returning multiple items
- The items won't be modified individually by the caller

```go
// Example: Collections return slices of values, not pointers
func ListResources() ([]Resource, error) {
  if noResults {
    return []Resource{}, nil  // Empty slice, not nil
  }
  return []Resource{{...}, {...}}, nil
}
```

### Why This Matters
This approach balances performance and idiomatic Go:

1. **Memory Efficiency**: Slices already contain a pointer to the backing array, so `[]Type` avoids an extra layer of indirection compared to `[]*Type`
2. **Nil Semantics**: 
   - For single objects, `nil` clearly indicates "not found"
   - For collections, an empty slice (`[]Type{}`) is preferred over `nil` as it avoids nil checks when ranging
3. **Consistency with Standard Library**: This pattern matches how the Go standard library handles return types

## Context Handling

- Always pass `context.Context` as the first parameter in service and store methods
- Use `context.Background()` sparingly - prefer passing context from the request
- Set appropriate timeouts for database operations
- Use context for cancellation and request tracing

```go
// Good: Pass context from request
func (h *Handler) Get() echo.HandlerFunc {
  return func(c echo.Context) error {
    ctx := c.Request().Context()
    account, err := h.service.GetAccount(ctx, input.UUID, userID)
    // ...
  }
}

// Service method signature
func (s *service) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error)
```

## Error Handling

### Custom Error Types
Define domain-specific errors for better error handling:

```go
var (
    ErrNotFound = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized access")
    ErrInvalidInput = errors.New("invalid input")
)

// Use errors.Is for checking
if errors.Is(err, ErrNotFound) {
    return c.JSON(http.StatusNotFound, apierr.ErrNotFound)
}
```

### Error Wrapping
Use `fmt.Errorf` with `%w` verb to wrap errors:

```go
if err != nil {
    return fmt.Errorf("unable to get account with UUID %s: %w", uuid, err)
}
```

### Handle Errors Once
When handling errors, follow these principles:

1. If the callee contract defines specific errors, use `errors.Is` or `errors.As` to handle different error types appropriately
2. If the error is recoverable, log it and degrade gracefully
3. If the error represents a domain-specific failure, return a well-defined error
4. Otherwise, return the error (wrapped or verbatim)

**Important**: Handle each error only once. Don't log an error and then return it, as the caller may handle it again.

## Input Validation

- Use struct tags for validation (`validate:"required"`)
- Validate at the handler layer before calling service
- Return consistent validation error responses

```go
// In handler
if err := c.Validate(input); err != nil {
    h.logger.Debug().Err(err).Msg("validation failed")
    return c.JSON(http.StatusBadRequest, apierr.ValidationError(err))
}
```

## Architecture Conventions

- Make sure the implementation in `store.go` correctly implements the interface in `types.go`.
- Services should return domain types (defined in types.go), not database types. This creates a clear separation of concerns between the service layer and the data access layer where the database implementation details are encapsulated within the store.

## Transaction Handling

For operations that require multiple database calls, use transactions:

```go
// In store.go
func (s *store) CreateAccountWithTransaction(ctx context.Context, input CreateInput) (*GetOutput, error) {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("unable to begin transaction: %w", err)
    }
    defer tx.Rollback() // Safe to call even after commit

    // Perform operations...
    
    if err := tx.Commit(); err != nil {
        return nil, fmt.Errorf("unable to commit transaction: %w", err)
    }
    
    return result, nil
}
```

## HTTP Response Conventions

### Status Codes
- `200 OK`: Successful GET, PUT
- `201 Created`: Successful POST
- `204 No Content`: Successful DELETE
- `400 Bad Request`: Validation errors
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Insufficient permissions
- `404 Not Found`: Resource doesn't exist
- `409 Conflict`: Resource conflict (duplicate)
- `500 Internal Server Error`: Unexpected errors

### Response Format
Always return consistent JSON responses:

```go
// Success response
return c.JSON(http.StatusOK, map[string]interface{}{
    "data": result,
})

// Error response
return c.JSON(http.StatusBadRequest, map[string]interface{}{
    "error": "validation failed",
    "details": validationErrors,
})
```

## Security Conventions

- Never log sensitive information (passwords, API keys, tokens)
- Use user UUIDs in logs, never internal IDs
- Validate user ownership of resources before operations
- Implement rate limiting for public endpoints
- Use HTTPS in production
- Validate and sanitize all inputs
- Use parameterized queries (sqlc handles this)

```go
// Always verify ownership
func (s *service) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error) {
    // Verify user has access to this resource
    if !s.hasAccess(ctx, uuid, userID) {
        return nil, ErrUnauthorized
    }
    // ... rest of logic
}
```

## Logging Conventions

Logging should primarily happen in the handler layer, closest to the user.

### Structured Logging
Always use structured logging with relevant fields:

```go
h.logger.Debug().
    Str("uuid", input.UUID).
    Str("userID", userData.UUID). // Use UUID, not ID
    Str("operation", "account_retrieval").
    Msg("processing request")
```

### Log Levels
- **Debug**: Request processing, successful operations
- **Info**: Important business events (rare)
- **Warn**: Recoverable errors, degraded functionality
- **Error**: Unrecoverable errors that need attention

### Performance Logging
Log slow operations:

```go
start := time.Now()
result, err := s.store.GetAccount(ctx, uuid, userID)
duration := time.Since(start)

if duration > 100*time.Millisecond {
    h.logger.Warn().
        Dur("duration", duration).
        Str("operation", "get_account").
        Msg("slow database operation")
}
```

### Debug Logging
Always implement debug logging before executing an action using the resource name followed by the action in noun form:

```go
h.logger.Debug().
  Interface("params", input).
  Msg("ledger creation")
```

Common debug log message patterns:
- "resource deletion"
- "resource updating"
- "resource creation"
- "resource retrieval"
- "resources listing"

### Error Logging
- Use "unable to <verb> <resource>" for error messages.
- Instead of "unable to get user", use "unable to get user with ID <userID>".
- Instead of "error updating ledger, please try again", use "unable to update ledger with ID <ledgerID>".
- Always add a Debug statement after error or successful log statements as "querying ledger params" when getting either "unable to find ledger" or "ledger found".

## Testing Conventions

### Test File Structure
- `handler_test.go` - HTTP handler tests
- `service_test.go` - Business logic tests  
- `store_test.go` - Data access tests

### Test Naming
```go
func TestService_GetAccount_Success(t *testing.T) {}
func TestService_GetAccount_NotFound(t *testing.T) {}
func TestHandler_Create_ValidationError(t *testing.T) {}
```

### Mock Interfaces
Use interfaces for easy mocking:

```go
type MockStore struct{}

func (m *MockStore) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error) {
    // Mock implementation
}
```
