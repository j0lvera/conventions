# Go Conventions

When writing Go code, you MUST follow these conventions.

## General Code Quality

- Code should be easy to read and understand.
- Keep the code as simple as possible. Avoid unnecessary complexity.
- Use meaningful names for variables, functions, etc. Names should reveal intent. But at the same time, they should follow Go conventions.
- Functions should be small and do one thing well.
- Prefer fewer arguments in functions. Ideally, aim for no more than two or three arguments.
  - If the function needs more than three arguments, consider using functional-options. You can read more about this in the example below.
- Only use comments when necessary, as they can become outdated. Instead, strive to make the code self-explanatory.
- When comments are used, they should add useful information that is not readily apparent from the code itself.
- Consider security implications of the code. Implement security best practices to protect against vulnerabilities and attacks.
- Follow the Go style guide.

## Service Architecture

Our services follow a clean, layered architecture pattern with clear separation of concerns:

1. **Handler Layer** (`handler.go`) - HTTP request/response handling
2. **Service Layer** (`service.go`) - Business logic implementation
3. **Store Layer** (`store.go`) - Data access and persistence
4. **Types** (`types.go`) - Interfaces, parameter objects, result objects

### File and Component Naming Conventions

#### Files
- `handler.go` - Contains HTTP handlers and routing logic
- `service.go` - Contains business logic implementation
- `store.go` - Contains data access logic
- `types.go` - Contains interfaces, parameter objects, and result objects

#### Components
- `Handler` - HTTP request handler struct
- `Service` - Business logic interface and implementation
- `Store` - Data access interface and implementation

We use these concise names because they're clear in context:

```go
// Example usage
svcStore := ledger.NewStore(dbClient)
svcService := ledger.NewService(svcStore, logger)
svcHandler := ledger.NewHandler(svcService, logger)
```

### Additional Structure Rules
- Don't use `models.go` because `sqlc` takes care of this.
- Always AVOID circular dependencies. Implement code that prevent import cycles.
- DON'T update code generated by `sqlc`.

## Functional Options Pattern

```go
// Functional option example
package main

type Server struct {
	config Config
}

func NewServer(config Config) (*Server, error) {
	return &Server{
		config: config,
	}, nil
}

type Config struct {
	listenAddr string
	id         string
	name       string
}

func (c Config) WithName(name string) Config {
	c.name = name
	return c
}

func (c Config) WithID(id string) Config {
	c.id = id
	return c
}

func (c Config) WithListenAddr(addr string) Config {
	c.listenAddr = addr
	return c
}

func NewConfig() Config {
	return Config{
		id:         "randomuuid",
		name:       "defaultName",
		listenAddr: ":3000",
	}
}

// Usage
func main() {
	config := NewConfig().
		WithID("longuuid").
		WithName("my server").
		WithListenAddr(":8000")
	server, _ := NewServer(config)
	fmt.Println(server)
}
```

## Builder Pattern

Use this pattern for creating service components:

```go
package pkgname

type Config struct {
  store Store
  logger *zerolog.Logger // Always include logger in all layers
}

// Implementation is lowercase (unexported)
type service struct {
  cfg Config
}

// Constructor returns the interface type
func NewService(store Store, logger *zerolog.Logger) Service {
  return &service{
    cfg: Config{
      store: store,
      logger: logger,
    }
  }
}
```

## Type Definitions

### Parameter Objects
Define purpose-specific input structs for each operation:

```go
type (
  // GetInput for retrieving a single resource
  GetInput struct {
    UUID string `param:"uuid" validate:"required"`
  }

  // CreateInput for creating a new resource
  CreateInput struct {
    Name        string `json:"name" validate:"required,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // UpdateInput for updating an existing resource
  UpdateInput struct {
    UUID        string `param:"uuid" validate:"required"`
    Name        string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // ListInput for listing resources with pagination
  ListInput[P any] struct {
    Pagination P
  }

  // DeleteInput for deleting a resource
  DeleteInput struct {
    GetInput
  }
)
```

### Result Objects
Define purpose-specific output structs for each operation:

```go
type (
  // GetOutput represents the response for a single resource
  GetOutput struct {
    UUID        string `json:"uuid"`
    Name        string `json:"name"`
    Description string `json:"description"`
  }

  // CreateOutput is often an alias for GetOutput
  CreateOutput = GetOutput

  // ListOutput represents a paginated list of items
  ListOutput[T any, P any] struct {
    Items      []T `json:"items"`
    Pagination P   `json:"pagination"`
  }
)
```

## Return Types

### Single Objects
Return pointers (`*Type`) when:
- The object might not exist (nil can represent "not found")
- The object is large or contains reference types
- The object might be modified by the caller

```go
// Example: Single object returns use pointers
func GetResource(id string) (*Resource, error) {
  if notFound {
    return nil, errors.New("not found")
  }
  return &Resource{...}, nil
}
```

### Collections
Return slices of values (`[]Type`) when:
- Returning multiple items
- The items won't be modified individually by the caller

```go
// Example: Collections return slices of values, not pointers
func ListResources() ([]Resource, error) {
  if noResults {
    return []Resource{}, nil  // Empty slice, not nil
  }
  return []Resource{{...}, {...}}, nil
}
```

### Why This Matters
This approach balances performance and idiomatic Go:

1. **Memory Efficiency**: Slices already contain a pointer to the backing array, so `[]Type` avoids an extra layer of indirection compared to `[]*Type`
2. **Nil Semantics**: 
   - For single objects, `nil` clearly indicates "not found"
   - For collections, an empty slice (`[]Type{}`) is preferred over `nil` as it avoids nil checks when ranging
3. **Consistency with Standard Library**: This pattern matches how the Go standard library handles return types

## Context Handling

- Always pass `context.Context` as the first parameter in service and store methods
- Use `context.Background()` sparingly - prefer passing context from the request
- Set appropriate timeouts for database operations
- Use context for cancellation and request tracing

```go
// Good: Pass context from request
func (h *Handler) Get() echo.HandlerFunc {
  return func(c echo.Context) error {
    ctx := c.Request().Context()
    account, err := h.service.GetAccount(ctx, input.UUID, userID)
    // ...
  }
}

// Service method signature
func (s *service) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error)
```

## Error Handling

### Custom Error Types
Define domain-specific errors for better error handling:

```go
var (
    ErrNotFound = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized access")
    ErrInvalidInput = errors.New("invalid input")
)

// Use errors.Is for checking
if errors.Is(err, ErrNotFound) {
    return c.JSON(http.StatusNotFound, apierr.ErrNotFound)
}
```

### Error Wrapping
Use `fmt.Errorf` with `%w` verb to wrap errors:

```go
if err != nil {
    return fmt.Errorf("unable to get account with UUID %s: %w", uuid, err)
}
```

### Handle Errors Once
When handling errors, follow these principles:

1. If the callee contract defines specific errors, use `errors.Is` or `errors.As` to handle different error types appropriately
2. If the error is recoverable, log it and degrade gracefully
3. If the error represents a domain-specific failure, return a well-defined error
4. Otherwise, return the error (wrapped or verbatim)

**Important**: Handle each error only once. Don't log an error and then return it, as the caller may handle it again.

## Input Validation

- Use struct tags for validation (`validate:"required"`)
- Validate at the handler layer before calling service
- Return consistent validation error responses

```go
// In handler
if err := c.Validate(input); err != nil {
    h.logger.Debug().Err(err).Msg("validation failed")
    return c.JSON(http.StatusBadRequest, apierr.ValidationError(err))
}
```

## Architecture Conventions

- Make sure the implementation in `store.go` correctly implements the interface in `types.go`.
- Services should return domain types (defined in types.go), not database types. This creates a clear separation of concerns between the service layer and the data access layer where the database implementation details are encapsulated within the store.

## Transaction Handling

For operations that require multiple database calls, use transactions:

```go
// In store.go
func (s *store) CreateAccountWithTransaction(ctx context.Context, input CreateInput) (*GetOutput, error) {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("unable to begin transaction: %w", err)
    }
    defer tx.Rollback() // Safe to call even after commit

    // Perform operations...
    
    if err := tx.Commit(); err != nil {
        return nil, fmt.Errorf("unable to commit transaction: %w", err)
    }
    
    return result, nil
}
```

## HTTP Response Conventions

### Status Codes
- `200 OK`: Successful GET, PUT
- `201 Created`: Successful POST
- `204 No Content`: Successful DELETE
- `400 Bad Request`: Validation errors
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Insufficient permissions
- `404 Not Found`: Resource doesn't exist
- `409 Conflict`: Resource conflict (duplicate)
- `500 Internal Server Error`: Unexpected errors

### Standardized Response Envelope
Use consistent response structure:

```go
type APIResponse struct {
    Data    interface{} `json:"data,omitempty"`
    Error   *APIError   `json:"error,omitempty"`
    Meta    *Meta       `json:"meta,omitempty"`
}

type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details interface{} `json:"details,omitempty"`
}

type Meta struct {
    RequestID string `json:"request_id"`
    Timestamp string `json:"timestamp"`
}

// Usage
return c.JSON(http.StatusOK, APIResponse{
    Data: result,
    Meta: &Meta{
        RequestID: c.Response().Header().Get(echo.HeaderXRequestID),
        Timestamp: time.Now().UTC().Format(time.RFC3339),
    },
})
```

## Security Conventions

- Never log sensitive information (passwords, API keys, tokens)
- Use user UUIDs in logs, never internal IDs
- Validate user ownership of resources before operations
- Implement rate limiting for public endpoints
- Use HTTPS in production
- Validate and sanitize all inputs
- Use parameterized queries (sqlc handles this)

```go
// Always verify ownership
func (s *service) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error) {
    // Verify user has access to this resource
    if !s.hasAccess(ctx, uuid, userID) {
        return nil, ErrUnauthorized
    }
    // ... rest of logic
}
```

## Logging Conventions

Logging should primarily happen in the handler layer, closest to the user.

### Structured Logging
Always use structured logging with consistent field names:

```go
h.logger.Debug().
    Str("resource_uuid", input.UUID).
    Str("user_uuid", userData.UUID).
    Str("operation", "account_retrieval").
    Msg("processing request")

// Error messages should include the resource identifier
h.logger.Error().Err(err).
    Str("resource_uuid", input.UUID).
    Msg("unable to get account")
```

### Log Levels
- **Debug**: Request processing, successful operations
- **Info**: Important business events (rare)
- **Warn**: Recoverable errors, degraded functionality
- **Error**: Unrecoverable errors that need attention

### Performance Logging
Log slow operations:

```go
start := time.Now()
result, err := s.store.GetAccount(ctx, uuid, userID)
duration := time.Since(start)

if duration > 100*time.Millisecond {
    h.logger.Warn().
        Dur("duration", duration).
        Str("operation", "get_account").
        Msg("slow database operation")
}
```

### Debug Logging
Always implement debug logging before executing an action using the resource name followed by the action in noun form:

```go
h.logger.Debug().
  Interface("params", input).
  Msg("ledger creation")
```

Common debug log message patterns:
- "resource deletion"
- "resource updating"
- "resource creation"
- "resource retrieval"
- "resources listing"

### Error Logging
- Use "unable to <verb> <resource>" for error messages.
- Always include resource identifiers in structured logging fields, not in message text.
- Use consistent field names: `resource_uuid`, `user_uuid`, etc.
- Always add a Debug statement after error or successful log statements as "querying ledger params" when getting either "unable to find ledger" or "ledger found".

```go
// Good: Structured logging with resource identifier
h.logger.Error().Err(err).
    Str("resource_uuid", input.UUID).
    Msg("unable to get account")

// Bad: Resource identifier in message text
h.logger.Error().Err(err).
    Msgf("unable to get account with ID %s", input.UUID)
```

## Middleware Conventions

### Request ID Middleware
Always include request ID for tracing:

```go
func RequestIDMiddleware() echo.MiddlewareFunc {
    return middleware.RequestIDWithConfig(middleware.RequestIDConfig{
        Generator: func() string {
            return uuid.New().String()
        },
    })
}

// Use in logging
h.logger.Debug().
    Str("request_id", c.Response().Header().Get(echo.HeaderXRequestID)).
    Msg("processing request")
```

### Recovery Middleware
Handle panics gracefully:

```go
func RecoveryMiddleware(logger *zerolog.Logger) echo.MiddlewareFunc {
    return middleware.RecoverWithConfig(middleware.RecoverConfig{
        LogErrorFunc: func(c echo.Context, err error, stack []byte) error {
            logger.Error().
                Err(err).
                Bytes("stack", stack).
                Msg("panic recovered")
            return nil
        },
    })
}
```

### Rate Limiting
Implement rate limiting for public endpoints:

```go
func RateLimitMiddleware() echo.MiddlewareFunc {
    return middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
        Store: middleware.NewRateLimiterMemoryStore(20), // 20 requests per second
        IdentifierExtractor: func(c echo.Context) (string, error) {
            return c.RealIP(), nil
        },
        ErrorHandler: func(c echo.Context, err error) error {
            return c.JSON(http.StatusTooManyRequests, map[string]string{
                "error": "rate limit exceeded",
            })
        },
    })
}
```

## Database Patterns

### Connection Pooling
Configure connection pools appropriately:

```go
// In database setup
config, err := pgxpool.ParseConfig(databaseURL)
if err != nil {
    return nil, fmt.Errorf("unable to parse database URL: %w", err)
}

config.MaxConns = 30
config.MinConns = 5
config.MaxConnLifetime = time.Hour
config.MaxConnIdleTime = time.Minute * 30

pool, err := pgxpool.ConnectConfig(ctx, config)
```

### Query Timeouts
Always use context with timeouts for database operations:

```go
func (s *store) GetAccount(ctx context.Context, uuid string) (*GetOutput, error) {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return s.db.Queries.GetAccount(ctx, uuid)
}
```

## Configuration Conventions

### Environment-based Config
Use environment variables with sensible defaults:

```go
type Config struct {
    Port        string `env:"PORT" envDefault:"8080"`
    DatabaseURL string `env:"DATABASE_URL,required"`
    LogLevel    string `env:"LOG_LEVEL" envDefault:"info"`
    Environment string `env:"ENVIRONMENT" envDefault:"development"`
}

func LoadConfig() (*Config, error) {
    cfg := &Config{}
    if err := env.Parse(cfg); err != nil {
        return nil, fmt.Errorf("unable to parse config: %w", err)
    }
    return cfg, nil
}
```

### Validation
Validate configuration on startup:

```go
func (c *Config) Validate() error {
    if c.Port == "" {
        return errors.New("port is required")
    }
    if c.DatabaseURL == "" {
        return errors.New("database URL is required")
    }
    return nil
}
```

## Server Lifecycle

### Graceful Shutdown
Implement proper shutdown handling:

```go
func (s *Server) Start() error {
    // Start server in goroutine
    go func() {
        if err := s.echo.Start(s.config.ListenAddr); err != nil && err != http.ErrServerClosed {
            s.logger.Fatal().Err(err).Msg("server failed to start")
        }
    }()

    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
    <-quit

    s.logger.Info().Msg("shutting down server...")

    // Graceful shutdown with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    return s.echo.Shutdown(ctx)
}
```

## Health Checks

Implement comprehensive health checks:

```go
type HealthChecker struct {
    db     *pgxpool.Pool
    logger *zerolog.Logger
}

func (h *HealthChecker) Check(c echo.Context) error {
    ctx, cancel := context.WithTimeout(c.Request().Context(), 5*time.Second)
    defer cancel()

    // Check database connectivity
    if err := h.db.Ping(ctx); err != nil {
        h.logger.Error().Err(err).Msg("database health check failed")
        return c.JSON(http.StatusServiceUnavailable, map[string]string{
            "status": "unhealthy",
            "error":  "database unavailable",
        })
    }

    return c.JSON(http.StatusOK, map[string]string{
        "status": "healthy",
        "timestamp": time.Now().UTC().Format(time.RFC3339),
    })
}
```

## Observability

### Metrics Collection
Implement basic metrics:

```go
type Metrics struct {
    RequestDuration *prometheus.HistogramVec
    RequestCount    *prometheus.CounterVec
}

func NewMetrics() *Metrics {
    return &Metrics{
        RequestDuration: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name: "http_request_duration_seconds",
                Help: "HTTP request duration in seconds",
            },
            []string{"method", "path", "status"},
        ),
        RequestCount: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Total number of HTTP requests",
            },
            []string{"method", "path", "status"},
        ),
    }
}
```

### Request Tracing
Add correlation IDs for request tracing:

```go
func (h *Handler) Get() echo.HandlerFunc {
    return func(c echo.Context) error {
        requestID := c.Response().Header().Get(echo.HeaderXRequestID)
        
        h.logger.Debug().
            Str("request_id", requestID).
            Str("operation", "account_retrieval").
            Msg("processing request")
        
        // ... rest of handler
    }
}
```

## Testing Conventions

### Test File Structure
- `handler_test.go` - HTTP handler tests
- `service_test.go` - Business logic tests  
- `store_test.go` - Data access tests

### Test Naming
```go
func TestService_GetAccount_Success(t *testing.T) {}
func TestService_GetAccount_NotFound(t *testing.T) {}
func TestHandler_Create_ValidationError(t *testing.T) {}
```

### Mock Interfaces
Use interfaces for easy mocking:

```go
type MockStore struct{}

func (m *MockStore) GetAccount(ctx context.Context, uuid string, userID int64) (*GetOutput, error) {
    // Mock implementation
}
```
