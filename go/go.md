# Go Conventions

When writing Go code, you MUST follow these conventions.

## General Code Quality

- Code should be easy to read and understand.
- Keep the code as simple as possible. Avoid unnecessary complexity.
- Use meaningful names for variables, functions, etc. Names should reveal intent. But at the same time, they should follow Go conventions.
- Functions should be small and do one thing well.
- Prefer fewer arguments in functions. Ideally, aim for no more than two or three arguments.
  - If the function needs more than three arguments, consider using functional-options. You can read more about this in the example below.
- Only use comments when necessary, as they can become outdated. Instead, strive to make the code self-explanatory.
- When comments are used, they should add useful information that is not readily apparent from the code itself.
- Consider security implications of the code. Implement security best practices to protect against vulnerabilities and attacks.
- Follow the Go style guide.

## Service Architecture

Our services follow a clean, layered architecture pattern with clear separation of concerns:

1. **Handler Layer** (`handler.go`) - HTTP request/response handling
2. **Service Layer** (`service.go`) - Business logic implementation
3. **Store Layer** (`store.go`) - Data access and persistence
4. **Types** (`types.go`) - Interfaces, parameter objects, result objects

### File and Component Naming Conventions

#### Files
- `handler.go` - Contains HTTP handlers and routing logic
- `service.go` - Contains business logic implementation
- `store.go` - Contains data access logic
- `types.go` - Contains interfaces, parameter objects, and result objects

#### Components
- `Handler` - HTTP request handler struct
- `Service` - Business logic interface and implementation
- `Store` - Data access interface and implementation

We use these concise names because they're clear in context:

```go
// Example usage
svcStore := ledger.NewStore(dbClient)
svcService := ledger.NewService(svcStore, logger)
svcHandler := ledger.NewHandler(svcService, logger)
```

### Additional Structure Rules
- Don't use `models.go` because `sqlc` takes care of this.
- Always AVOID circular dependencies. Implement code that prevent import cycles.
- DON'T update code generated by `sqlc`.

## Functional Options Pattern

```go
// Functional option example
package main

type Server struct {
	config Config
}

func NewServer(config Config) (*Server, error) {
	return &Server{
		config: config,
	}, nil
}

type Config struct {
	listenAddr string
	id         string
	name       string
}

func (c Config) WithName(name string) Config {
	c.name = name
	return c
}

func (c Config) WithID(id string) Config {
	c.id = id
	return c
}

func (c Config) WithListenAddr(addr string) Config {
	c.listenAddr = addr
	return c
}

func NewConfig() Config {
	return Config{
		id:         "randomuuid",
		name:       "defaultName",
		listenAddr: ":3000",
	}
}

// Usage
func main() {
	config := NewConfig().
		WithID("longuuid").
		WithName("my server").
		WithListenAddr(":8000")
	server, _ := NewServer(config)
	fmt.Println(server)
}
```

## Builder Pattern

Use this pattern for creating service components:

```go
package pkgname

type Config struct {
  store Store
  logger *zerolog.Logger // Always include logger in all layers
}

// Implementation is lowercase (unexported)
type service struct {
  cfg Config
}

// Constructor returns the interface type
func NewService(store Store, logger *zerolog.Logger) Service {
  return &service{
    cfg: Config{
      store: store,
      logger: logger,
    }
  }
}
```

## Type Definitions

### Parameter Objects
Define purpose-specific input structs for each operation:

```go
type (
  // GetInput for retrieving a single resource
  GetInput struct {
    UUID string `param:"uuid" validate:"required"`
  }

  // CreateInput for creating a new resource
  CreateInput struct {
    Name        string `json:"name" validate:"required,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // UpdateInput for updating an existing resource
  UpdateInput struct {
    UUID        string `param:"uuid" validate:"required"`
    Name        string `json:"name,omitempty" validate:"omitempty,min=1,max=255"`
    Description string `json:"description,omitempty" validate:"omitempty,max=255"`
  }

  // ListInput for listing resources with pagination
  ListInput[P any] struct {
    Pagination P
  }

  // DeleteInput for deleting a resource
  DeleteInput struct {
    GetInput
  }
)
```

### Result Objects
Define purpose-specific output structs for each operation:

```go
type (
  // GetOutput represents the response for a single resource
  GetOutput struct {
    UUID        string `json:"uuid"`
    Name        string `json:"name"`
    Description string `json:"description"`
  }

  // CreateOutput is often an alias for GetOutput
  CreateOutput = GetOutput

  // ListOutput represents a paginated list of items
  ListOutput[T any, P any] struct {
    Items      []T `json:"items"`
    Pagination P   `json:"pagination"`
  }
)
```

## Return Types

### Single Objects
Return pointers (`*Type`) when:
- The object might not exist (nil can represent "not found")
- The object is large or contains reference types
- The object might be modified by the caller

```go
// Example: Single object returns use pointers
func GetResource(id string) (*Resource, error) {
  if notFound {
    return nil, errors.New("not found")
  }
  return &Resource{...}, nil
}
```

### Collections
Return slices of values (`[]Type`) when:
- Returning multiple items
- The items won't be modified individually by the caller

```go
// Example: Collections return slices of values, not pointers
func ListResources() ([]Resource, error) {
  if noResults {
    return []Resource{}, nil  // Empty slice, not nil
  }
  return []Resource{{...}, {...}}, nil
}
```

### Why This Matters
This approach balances performance and idiomatic Go:

1. **Memory Efficiency**: Slices already contain a pointer to the backing array, so `[]Type` avoids an extra layer of indirection compared to `[]*Type`
2. **Nil Semantics**: 
   - For single objects, `nil` clearly indicates "not found"
   - For collections, an empty slice (`[]Type{}`) is preferred over `nil` as it avoids nil checks when ranging
3. **Consistency with Standard Library**: This pattern matches how the Go standard library handles return types

## Error Handling

### Handle Errors Once
When handling errors, follow these principles:

1. If the callee contract defines specific errors, use `errors.Is` or `errors.As` to handle different error types appropriately
2. If the error is recoverable, log it and degrade gracefully
3. If the error represents a domain-specific failure, return a well-defined error
4. Otherwise, return the error (wrapped or verbatim)

**Important**: Handle each error only once. Don't log an error and then return it, as the caller may handle it again.

## Architecture Conventions

- Make sure the implementation in `store.go` correctly implements the interface in `types.go`.
- Services should return domain types (defined in types.go), not database types. This creates a clear separation of concerns between the service layer and the data access layer where the database implementation details are encapsulated within the store.

## Security Conventions

- Never log sensitive information, e.g., passwords, API keys, user ID (use user UUID instead), etc.

## Logging Conventions

Logging should primarily happen in the handler layer, closest to the user.

### Debug Logging
Always implement debug logging before executing an action using the resource name followed by the action in noun form:

```go
h.logger.Debug().
  Interface("params", input).
  Msg("ledger creation")
```

Common debug log message patterns:
- "resource deletion"
- "resource updating"
- "resource creation"
- "resource retrieval"
- "resources listing"

### Error Logging
- Use "unable to <verb> <resource>" for error messages.
- Instead of "unable to get user", use "unable to get user with ID <userID>".
- Instead of "error updating ledger, please try again", use "unable to update ledger with ID <ledgerID>".
- Always add a Debug statement after error or successful log statements as "querying ledger params" when getting either "unable to find ledger" or "ledger found".
