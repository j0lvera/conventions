# Go Conventions

When writing Go code, you MUST follow these conventions.

## General Code Quality

- Code should be easy to read and understand.
- Keep the code as simple as possible. Avoid unnecessary complexity.
- Use meaningful names for variables, functions, etc. Names should reveal intent. But at the same time, they should follow Go conventions.
- Functions should be small and do one thing well.
- Prefer fewer arguments in functions. Ideally, aim for no more than two or three arguments.
  - If the function needs more than three arguments, consider using functional-options. You can read more about this in the example below.
- Only use comments when necessary, as they can become outdated. Instead, strive to make the code self-explanatory.
- When comments are used, they should add useful information that is not readily apparent from the code itself.
- Consider security implications of the code. Implement security best practices to protect against vulnerabilities and attacks.
- Follow the Go style guide.

## Project Structure

- Use the handler, service, and repository layers to separate concerns.
- Use `handler.go` for HTTP handlers.
- Use `service.go` for business logic.
- Use `store.go` for data access.
- Use `types.go` for custom types, interfaces, and constants.
- Don't use `models.go` because `sqlc` takes care of this.
- Always AVOID circular dependencies. Implement code that prevent import cycles.
- DON'T update code generated by `sqlc`.

## Functional Options Pattern

```go
// Functional option example
package main

type Server struct {
	config Config
}

func NewServer(config Config) (*Server, error) {
	return &Server{
		config: config,
	}, nil
}

type Config struct {
	listenAddr string
	id         string
	name       string
}

func (c Config) WithName(name string) Config {
	c.name = name
	return c
}

func (c Config) WithID(id string) Config {
	c.id = id
	return c
}

func (c Config) WithListenAddr(addr string) Config {
	c.listenAddr = addr
	return c
}

func NewConfig() Config {
	return Config{
		id:         "randomuuid",
		name:       "defaultName",
		listenAddr: ":3000",
	}
}

// Usage
func main() {
	config := NewConfig().
		WithID("longuuid").
		WithName("my server").
		WithListenAddr(":8000")
	server, _ := NewServer(config)
	fmt.Println(server)
}
```

## Architecture Conventions

- Make sure the implementation in `store.go` correctly implements the interface in `types.go`.
- Services should return domain types (defined in types.go), not database types. This creates a clear separation of concerns between the service layer and the data access layer where the database implementation details are encapsulated within the store.

## Security Conventions

- Never log sensitive information, e.g., passwords, API keys, user ID (use user UUID instead), etc.

## Error Logging Conventions

- Use "unable to <verb> <resource>" for error messages.
- Instead of "unable to get user", use "unable to get user with ID <userID>".
- Instead of "error updating ledger, please try again", use "unable to update ledger with ID <ledgerID>".
- Always add a Debug statement after error or successful log statements as "querying ledger params" when getting either "unable to find ledger" or "ledger found".
